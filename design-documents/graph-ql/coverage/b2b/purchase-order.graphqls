type Mutation {
    addPurchaseOrderComment(input: AddPurchaseOrderCommentInput!): AddPurchaseOrderCommentOutput @doc(description: "Add a comment to an existing purchase order")
    addPurchaseOrderItemsToCart(input: AddPurchaseOrderItemsToCartInput!): AddPurchaseOrderItemsToCartOutput @doc(description: "Add all items from the purchase order to shopping cart")
    validatePurchaseOrder(input: ValidatePurchaseOrderInput!): ValidatePurchaseOrderOutput @doc(description: "Validate purchase order")
    approvePurchaseOrders(input: ApprovePurchaseOrdersInput!): ApprovePurchaseOrdersOutput @doc(description: "Approve purchase orders")
    cancelPurchaseOrder(input: CancelPurchaseOrderInput!): CancelPurchaseOrderOutput @doc(description: "Cancel purchase order")
    rejectPurchaseOrders(input: RejectPurchaseOrderInputs!): RejectPurchaseOrderOutputs @doc(description: "Reject purchase orders")
    placePurchaseOrder(input: PlacePurchaseOrderInput!): PlaceOrderOutput @doc(description: "Convert purchase order to an order")
    setPaymentMethodAndPlacePurchaseOrder(input: SetPaymentMethodAndPlacePurchaseOrderInput!): PlaceOrderOutput @doc(description: "Convert purchase order to an order")
}

input PlacePurchaseOrderInput {
    purchase_order_uid: ID!
}

input SetPaymentMethodAndPlacePurchaseOrderInput {
    purchase_order_uid: ID!,
    payment_method: PaymentMethodInput! @doc(description: "The payment method data to apply to the purchase order.")
}

input AddPurchaseOrderItemsToCartInput {
    purchase_order_uid: ID!
    cart_id: String! @doc(description: "The ID to assign to the cart.")
    replace_existing_cart_items: Boolean! @doc(description: "Replace existing cart or merge items")
}

type AddPurchaseOrderItemsToCartOutput {
    purchase_order: PurchaseOrder
    add_purchase_order_items_to_cart_user_errors: [AddPurchaseOrderItemsToCartError!]! @doc(description: "An array of errors encountered while adding products to the customer's cart.")
}

type AddPurchaseOrderItemsToCartError {
    message: string!
    type: AddPurchaseOrderItemsToCartErrorType!
}

enum AddPurchaseOrderItemsToCartErrorType @doc(description: "A list of possible error types.") {
    PRODUCT_NOT_FOUND
    NOT_SALABLE
    INSUFFICIENT_STOCK
    UNDEFINED
}

input ValidatePurchaseOrderInput {
    purchase_order_uid: ID!
}

type ValidatePurchaseOrderOutput {
    purchase_order: PurchaseOrder
    errors: [ValidatePurchaseOrderError!]! @doc(description: "An array of error messages encountered while performing the operation.")
}

type ValidatePurchaseOrderError {
    message: string!
    type: ValidatePurchaseOrderErrorType!
}

enum ValidatePurchaseOrderErrorType {
    UNDEFINED
}

input ApprovePurchaseOrderInput {
    purchase_order_uid: ID!
}

type ApprovePurchaseOrderOutput {
    purchase_order: PurchaseOrder
    errors: [ApprovePurchaseOrderError!]! @doc(description: "An array of error messages encountered while performing the operation.")
}

input ApprovePurchaseOrdersInput {
    purchase_order_uids: [ID!]!
}

type ApprovePurchaseOrdersOutput {
    purchase_orders: [PurchaseOrder!]!
    errors: [ApprovePurchaseOrderError!]! @doc(description: "An array of error messages encountered while performing the operation.")
}

type ApprovePurchaseOrderError {
    message: string!
    type: ApprovePurchaseOrderErrorType!
}

enum ApprovePurchaseOrderErrorType {
    UNDEFINED
}

input CancelPurchaseOrderInput {
    purchase_order_uid: ID!
}

type CancelPurchaseOrderOutput {
    purchase_order: PurchaseOrder
    errors: [CancelPurchaseOrderError!]! @doc(description: "An array of error messages encountered while performing the operation.")
}

type CancelPurchaseOrderError {
    message: string!
    type: CancelPurchaseOrderErrorType!
}

enum CancelPurchaseOrderErrorType {
    UNDEFINED
}

input RejectPurchaseOrderInput {
    purchase_order_uid: ID!
}

type RejectPurchaseOrderOutput {
    purchase_order: PurchaseOrder
    errors: [RejectPurchaseOrderError!]! @doc(description: "An array of error messages encountered while performing the operation.")
}

input RejectPurchaseOrdersInput {
    purchase_order_uids: [ID!]!
}

type RejectPurchaseOrdersOutput {
    purchase_orders: [PurchaseOrder!]!
    errors: [RejectPurchaseOrderError!]! @doc(description: "An array of error messages encountered while performing the operation.")
}

type RejectPurchaseOrderError {
    message: string!
    type: RejectPurchaseOrderErrorType!
}

enum RejectPurchaseOrderErrorType {
    UNDEFINED
}

input AddPurchaseOrderCommentInput {
    purchase_order_uid: ID!
    comment: String!
}

type AddPurchaseOrderCommentOutput {
    purchase_order: PurchaseOrder
    comment: PurchaseOrderComment
    errors: [AddPurchaseOrderCommentError!]! @doc(description: "An array of error messages encountered while performing the operation.")
}

type AddPurchaseOrderCommentError {
    message: string!
    type: AddPurchaseOrderCommentErrorType!
}

enum AddPurchaseOrderCommentErrorType {
    UNDEFINED
}

type Customer {
    purchase_orders(filter: PurchaseOrdersFilterInput, currentPage: Int = 1, pageSize: Int = 20): PurchaseOrders @doc(description: "A list of purchase orders visible to the customer")
    purchase_order(uid: ID!): PurchaseOrder @doc(description: "Purchase order details")
    purchase_orders_enabled: Boolean! @doc(description: "Whether purchase orders functionality is enabled for current customer. Takes into account global and company-level settings")
}

input PurchaseOrdersFilterInput {
    status: PurchaseOrderStatus @doc(description: "Filter by the status of the purchase order")
    company_purchase_orders: Boolean @doc(description: "Include only POs made by subordinate users within the company")
    require_my_approval: Boolean @doc(description: "Include only POs that are waiting for the customerâ€™s approval")
    createdBy: FilterStringTypeInput @doc(description: "Filter by the name of the user who created the purchase order")
    createdDate: FilterRangeTypeInput @doc(description: "Filter by the creation date of the purchase order")
}

type PurchaseOrders {
    items: [PurchaseOrder]!
    page_info: SearchResultPageInfo
    total_count: Int
}

type PurchaseOrder {
    uid: ID! @doc(description: "Unique identifier for the purcahse order")
    number: String! @doc(description: "The purchase order number")
    order: CustomerOrder @doc(description: "The reference to the order placed based on the purchase order")
    created_at: String! @doc(description: "The date the purchase order was created")
    updated_at: String! @doc(description: "The date the purchase order was last updated")
    created_by: String! @doc(description: "The name of the user who created the purchase order")
    status: PurchaseOrderStatus! @doc(description: "The current status of the purcahse order")
    total: PurchaseOrderTotal @doc(description: "Contains details about the calculated totals for the purchase order")
    comments(currentPage: Int = 1, pageSize: Int = 20): PurchaseOrderComments @doc(description: "Purchase order comments")
    payment_methods: [PaymentMethod] @doc(description: "Payment details for the purchase order")
    items(currentPage: Int = 1, pageSize: Int = 20): PurchaseOrderItems @doc(description: "Items that belong to the purchase order")
    history_log(currentPage: Int = 1, pageSize: Int = 20): PurchaseOrderHistoryLog @doc(description: "The log of the events related to the purchase order")
    available_actions: [PurchaseOrderAction] @doc(description: "Purcahse order actions available to the customer. Can be used to display action buttons on the client")
}

type CustomerOrder @doc(description: "Contains details about each of the customer's orders.") {
    id: ID! @doc(description: "The unique ID for a `CustomerOrder` object.")
    order_date: String! @doc(description: "The date the order was placed.")
    status: String! @doc(description: "The current status of the order.")
    number: String! @doc(description: "The order number.")
    items: [OrderItemInterface] @doc(description: "An array containing the items purchased in this order.") @resolver(class: "Magento\\SalesGraphQl\\Model\\Resolver\\OrderItems")
    total: OrderTotal @doc(description: "Details about the calculated totals for this order.") @resolver(class: "Magento\\SalesGraphQl\\Model\\Resolver\\OrderTotal")
    invoices: [Invoice]! @doc(description: "A list of invoices for the order.") @resolver(class: "Magento\\SalesGraphQl\\Model\\Resolver\\Invoices")
    shipments: [OrderShipment] @doc(description: "A list of shipments for the order.") @resolver(class: "Magento\\SalesGraphQl\\Model\\Resolver\\Shipments")
    credit_memos: [CreditMemo] @doc(description: "A list of credit memos.") @resolver(class: "Magento\\SalesGraphQl\\Model\\Resolver\\CreditMemos")
    payment_methods: [OrderPaymentMethod] @doc(description: "Payment details for the order.")
    comments: [SalesCommentItem] @doc(description: "Comments about the order.")
    increment_id: String @deprecated(reason: "Use the `id` field instead.")
    order_number: String! @deprecated(reason: "Use the `number` field instead.")
    created_at: String @deprecated(reason: "Use the `order_date` field instead.")
    grand_total: Float  @deprecated(reason: "Use the `totals.grand_total` field instead.")
}

enum PurchaseOrderAction {
    REJECT
    CANCEL
    VALIDATE
    APPROVE
}

type PurchaseOrderComments {
    items: [PurchaseOrderComment]!
    page_info: SearchResultPageInfo
    total_count: Int!
}

type PurchaseOrderComment {
    uid: ID! @doc(description: "Unique identifier of the comment.")
    created_at: String! @doc(description: "The date and time when the comment was created")
    author: PurchaseOrderCommentAuthor! @doc(description: "The name of the user who left the comment")
    text: String! @doc(description: "The text of the comment")
}

type PurchaseOrderCommentAuthor {
    firstname: String! @doc(description: "First name of the user who left the purchase order comment")
    lastname: String! @doc(description: "Last name of the user who left the purchase order comment")
}

type PurchaseOrderHistoryLog {
    items: [PurchaseOrderHistoryItem]!
    page_info: SearchResultPageInfo
    total_count: Int
}

type PurchaseOrderHistoryItem {
    uid: ID! @doc(description: "Unique identifier of the purchase rder history item.")
    created_at: String! @doc(description: "The date and time when the event happened.")
    description: String! @doc(description: "Description of the event.")
}

type PurchaseOrderItems {
    items: [PurchaseOrderItemInterface]!
    page_info: SearchResultPageInfo
    total_count: Int!
}

type PurchaseOrderTotal @doc(description: "Contains details about the sales total amounts used to calculate the final price") {
    subtotal: Money! @doc(description: "The subtotal of the purchase order, excluding shipping, discounts, and taxes")
    discounts: [Discount] @doc(description: "The applied discounts to the purchase order")
    estimated_total_tax: Money! @doc(description: "The amount of tax applied to the purchase order")
    estimated_taxes: [TaxItem] @doc(description: "The purchase order tax details")
    grand_total: Money! @doc(description: "The final total amount, including shipping, discounts, and taxes")
    base_grand_total: Money! @doc(description: "The final base grand total amount in the base currency")
    total_shipping: Money! @doc(description: "The shipping amount for the order")
    shipping_handling: ShippingHandling @doc(description: "Contains details about the shipping and handling costs for the purchase purchase order")
}

interface PurchaseOrderItemInterface @doc(description: "Purchase order item details") {
    uid: ID! @doc(description: "The unique identifier of the purchase order item")
    product_name: String @doc(description: "The name of the base product")
    product_sku: String! @doc(description: "The SKU of the base product")
    product_url_key: String @doc(description: "URL key of the base product")
    product_sale_price: Money! @doc(description: "The sale price of the base product, including selected options")
    discounts: [Discount] @doc(description: "The final discount information for the product")
    selected_options: [PurchaseOrderItemOption] @doc(description: "The selected options for the base product, such as color or size")
    entered_options: [PurchaseOrderItemOption] @doc(description: "The entered option for the base product, such as a logo or image")
    quantity: Float! @doc(description: "The number of units for this item")
}

type PurchaseOrderItem implements PurchaseOrderItemInterface {

}

type PurchaseOrderBundleItem implements PurchaseOrderItemInterface {
    parent_product_sku: String! @doc(description: "SKU of the bundle itself")
    parent_product_quantity: Float! @doc(description: "Quantity of the bundle itself")
}

type PurchaseOrderItemOption @doc(description: "Represents purcahse order item options") {
    uid: ID! @doc(description: "The unique ID of the option")
    label: String! @doc(description: "The label of the option")
    value: String! @doc(description: "The value of the option")
    sort_order: Int! @doc(description: "The sort order of the option")
}

enum PurchaseOrderStatus {
    PENDING
    APPROVAL_REQUIRED
    APPROVED
    ORDER_IN_PROGRESS
    ORDER_PLACED
    ORDER_FAILED
    REJECTED
    CANCELED
}

### Changes to QuoteGraphQl module

type AvailablePaymentMethod {
    is_deferred: Boolean! @doc(description: "Whether the payment method is an online integration")
}

### Not related to purchase orders

type CustomerAddress {
    # This field must be added to the CustomerAddress type definition directly in CustomerGraphQl module
    country: Country @doc(description: "The customer's country")
}

input CartItemInput {
    # This field must be added to the CartItemInput type definition directly in QuoteGraphQl module
    parent_quantity: Float @doc(description: "Parent quantity can be used when adding complex product to cart. For example bundle products")
}

